import ch.so.agi.gretl.tasks.*
import ch.so.agi.gretl.api.TransferSet

apply plugin: 'ch.so.agi.gretl'


// Load properties file which is located in the project directory of the specific schema
project.ext.createSchemaProperties = new Properties()
project(':topic-schema-tasks').file('createSchema.properties').withInputStream { project.createSchemaProperties.load(it) }

// Get the suffix of the schema directory (if any)
def schemaSuffix = ''
if ( project.property('schemaDirName').split('schema_').size() > 1 ) {
    schemaSuffix = '_' + project.property('schemaDirName').split('schema_').getAt(1)
}

// Get the schema name either from the properties file if it's set,
// or construct the schema name from the topic directory name and the schema directory suffix
// (This uses the Elvis operator, http://groovy-lang.org/operators.html#_elvis_operator)
def schema = createSchemaProperties.getProperty('schemaName') ?: project.property('topicName') + schemaSuffix
def schemaVersion = createSchemaProperties.getProperty('schemaVersion') as Integer
if (!schemaVersion) {
    throw new Exception("The schemaVersion property is missing")
}
project.ext.set('schemaName', "${schema}_v${schemaVersion}".toString())

// Determine automatically in which DB to create the schema
def targetDbName = ( project.property('schemaDirName').contains('_pub')  ) ? 'pub' : 'edit'
// However, if the dbName property is set and is not null it must override the default
if ( project.hasProperty('dbName') && project.dbName && project.dbName != 'default') {
    targetDbName = project.property('dbName')
}

project.ext {
    dbUri = ( targetDbName == 'pub' ) ? project.property('dbUriPub') : project.property('dbUriEdit')
    dbUser = ( targetDbName == 'pub' ) ? project.property('dbUserPub') : project.property('dbUserEdit')
    dbPwd = ( targetDbName == 'pub' ) ? project.property('dbPwdPub') : project.property('dbPwdEdit')
}



task dropSchemaShared(type: SqlExecutor) {
    group = 'Drop schema'
    description = 'Drop DB schema and schema roles if they exist'
    doLast {
        println "DB schema ${project.schemaName} and schema roles dropped (or they did not exist)"
    }
    database = [project.dbUri, project.dbUser, project.dbPwd]
    sqlFiles = ['drop_schema.sql', 'drop_role.sql']
    // Dies wird z.B.bei Publikationsschemen, die zus채tzlich auch auf der Edit-DB vorhanden sein m체ssen, Probleme machen; Abhilfe: Die Rollennamen sollen auch die DB-Namen enthalten, z.B.: editdb_arp_nutzungsplanung_pub_read, pubdb_arp_nutzungsplanung_pub_read; oder noch besser: Falls man in Jenkins die voreingestellte DB umstellt, wird zus채tzlich ein Parameter rolePrefix o.채. gesetzt, und es wird nur dann der DB-Name dem Gruppennamen vorangestellt.
    sqlParameters = [dbSchema: project.schemaName]
}

task createRolesShared(type: SqlExecutor) {
    group = 'Create schema'
    description = 'Create roles for reading from and writing to the DB schema'
    doLast {
        println "DB schema roles for schema ${project.schemaName} created"
    }
    database = [project.dbUri, project.dbUser, project.dbPwd]
    sqlFiles = ['create_role.sql']
    sqlParameters = [dbSchema: project.schemaName]
}

task createSchemaShared(type: Ili2pgImportSchema) {
    group = 'Create schema'
    description = 'Create DB schema and tables according to INTERLIS model'
    dependsOn 'createRolesShared'
    doLast {
        println "DB schema ${project.schemaName} and tables created"
    }
    database = [project.dbUri, project.dbUser, project.dbPwd]
    dbschema = project.schemaName
    models = project.createSchemaProperties.getProperty('models')
    // uses the Elvis operator, http://groovy-lang.org/operators.html#_elvis_operator
    defaultSrsCode = project.createSchemaProperties.getProperty('defaultSrsCode') ?: 2056
    createGeomIdx = project.createSchemaProperties.getProperty('createGeomIdx') ?: true
    createFk = project.createSchemaProperties.getProperty('createFk') ?: true
    createFkIdx = project.createSchemaProperties.getProperty('createFkIdx') ?: true
    createUnique = project.createSchemaProperties.getProperty('createUnique') ?: true
    createEnumTabs = project.createSchemaProperties.getProperty('createEnumTabs') ?: true
    beautifyEnumDispName = project.createSchemaProperties.getProperty('beautifyEnumDispName') ?: true
    createMetaInfo = project.createSchemaProperties.getProperty('createMetaInfo') ?: true
    createNumChecks = project.createSchemaProperties.getProperty('createNumChecks') ?: true
    nameByTopic = project.createSchemaProperties.getProperty('nameByTopic') ?: true
    strokeArcs = project.createSchemaProperties.getProperty('strokeArcs') ?: true
    // TODO: createImportTabs = true ?
    createBasketCol = project.createSchemaProperties.getProperty('createBasketCol') ?: false
    createDatasetCol = project.createSchemaProperties.getProperty('createDatasetCol') ?: false
}

task configureSchemaShared(type: SqlExecutor) {
    group = 'Configure schema'
    description = 'Set comment on schema, grant permissions, and more'
    doLast {
        println "DB schema ${project.schemaName} configured"
    }
    database = [project.dbUri, project.dbUser, project.dbPwd]
    sqlFiles = [project(':topic-schema-tasks').file('comment_on_schema.sql').getPath()]
    sqlParameters = [dbSchema: project.schemaName]
}
